\section{Implementation in Solidity}

Each poker table implements a multiparty state channel as a smart contract in Solidity. It consists of data declarations and public and private functions. Public function can further be distinguished by constant functions, that only read from the contract storage, and non-constant functions, that can be invoked through transactions to change the state of the contract storage.

A transaction that invokes a contract function carries the function name and the arguments passed to the function. The transaction also contains a fee, which roughly corresponds to the computational cost of executing the operation in the smart contract.

In appendix A, we provide our reference implementation of smart contract code for multiparty state channels. In the following we explain core concepts.

\subsection{Data Structures}

In addition to the state variables (\(LNR\), \(exitHand\), \(NRH\), \(NRT\)), which have been defined in the previous section, two important structures are \(Seats\) and \(Hands\), which we will examine now.

A table contract holds an array of 2 to 10 \(Seats\), a data-structure being able to hold the data of one seated player at a time, no lap dances allowed. The \(Seat\) is implemented as a struct with the following 4 attributes:

\begin{verbatim}
  struct Seat {
    address senderAddr;
    address signerAddr;
    uint256 amount;
    uint256 exitHand;
  }
  Seat[] public seats;
\end{verbatim}

\begin{description}
\item[SenderAddr:] The \(senderAddress\) is the address of the wallet used by the player to join the table and holding the player's bankroll.
\item[SignerAddr:] The \(signerAddress\) is the address of an additional private key created and used under the control of the player to sign receipts about commitments during betting.
\item[Amount:] The \(amount\) stores the value of tokens that the player chose to transfer to the state channel to be used in bets during the game.
\item[ExitHand:] The \(exitHand\) parameter is used to signal the intention to leave the state channel to other participants. Hence, it is kept at a value of 0, until the player signals to leave the channel. Once the player signals to leave the channel, the \(exitHand\) will take the ID of the latest betting round executed in the state channel in which the player participated.
\end{description}

An additional data structure is maintained in the smart contract which is only used in the case of dispute. An array is used to collect all receipts of commitments and distributions for each betting round. Each \(Hand\) element is implemented as a struct with the following 3 attributes:

\begin{verbatim}
  struct Hand {
    mapping (address => uint256) ins;
    uint256 claimCount;
    mapping (address => uint256) outs;
  }
  Hand[] public hands;
\end{verbatim}

\begin{description}
\item[Ins:] This mapping holds the commitment value of the receipt with the highest sequence number for each player.
\item[ClaimCount:] The \(claimCount\) stores the sequence number of the distribution receipt. 
\item[Outs:] This mapping is filled by the distribution generated by the oracle at the end of each hand. It holds the value(s) of payment(s) for the winner(s) of this hand.
\end{description}


\subsection{Functions}

The contract implements the following functions:

\begin{description}
\item[TokenFallback():] This function allows new players to join the table by submitting tokens into the control of the smart contract. Already seated players can use this function to rebuy, increasing their balance at the table. 
\item[Leave():] The leave function allows players to signal their intention to leave the table. This function can only be invoked by an active player once. It will trigger a netting request, notifying all other participants about the necessity to settle on the new balances at the end of the current betting round.
\item[Settle():] The settle function receives a resolution, which holds the new balances of all players at a specific hand. The resolution needs to be signed by all players and the oracle alike, to be valid and accepted into the smart contract. A valid resolution will trigger a netting, updating all players' balances and removing players that are signaling to leave the table, if the netting exceeded the players' \(exitHand\).
\item[Submit():] The submit function can be called by anyone, receiving an array of receipts of commitments and distributions. Each receipt is evaluated by sequence identifier and signature, then written into contract storage. Receipts are only accepted into contract storage if the state channel is in a dispute resolution state (\(LNH < NRH\)).
\item[Net():] The net function sums up all receipts of commitments and distributions that have been collected in the challenge period. It can only be invoked once the time of the challenge period expired.
\end{description}



\subsection{Joining a Channel}

With ERC20 a token standard has evolved that describes the functions and events for an Ethereum token contract  to implement. With \(transfer()\) token can be transferred from one account to another. Unfortunately, ERC20 still has a couple of disadvantages, that hinder the interoperability with smart contracts that act as trust-free agents for escrow or exchange to the token, like our multiparty state channels:

\begin{enumerate}
\item A transaction depositing tokens into a smart contract requires two separate transactions: The depositor has to call \(approve()\) on token contract, only then the receiver contract can invoke \(transferFrom()\) to pull the tokens into his account.
\item Inability of handling incoming token transactions: ERC20 token transaction is a call of the \(transfer()\) function inside token contract. The ERC20 token contract is not notifying the receiver that a transaction occurred. Also there is no way to handle incoming token transactions for contracts and no way to reject any non-supported tokens.
\end{enumerate}

These disadvantages would force users to send multiple transactions to join tables and would increase gas usage through excessive inter-contract communication.

We have adopted ERC223, which solves these disadvantages, by implementing a standard function to handle token transfers that is called from token contract when a token holder is sending tokens. This function works like the fallback function for Ether transactions:

\begin{verbatim}
  function tokenFallback(
      address _from,
      uint256 _value,
      bytes _data
    );
\end{verbatim}

The table contract implements this function to accept token transaction when players join the table and maps the parameters as follows:

\begin{description}
\item[\_from] The token sender.
\item[\_value] The amount of incoming tokens.
\item[\_data] The first 20 bytes carry the \(signerAddress\).
\end{description}

By implementing the ERC223 token standard players can join tables by sending a single transaction, extending the interoperability of our poker tables to all ERC223 supporting wallets.


